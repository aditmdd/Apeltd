{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;\nexports.clearNodeFolder = clearNodeFolder;\nexports.enforceOptions = enforceOptions;\n\nvar _util = require(\"./util.js\");\n\nvar _methodChooser = require(\"./method-chooser.js\");\n\nvar _options = require(\"./options.js\");\n/**\r\n * Contains all open channels,\r\n * used in tests to ensure everything is closed.\r\n */\n\n\nvar OPEN_BROADCAST_CHANNELS = new Set();\nexports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;\nvar lastId = 0;\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = (0, _options.fillOptionsWithDefaults)(options);\n  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening\n\n  this._iL = false;\n  /**\r\n   * _onMessageListener\r\n   * setting onmessage twice,\r\n   * will overwrite the first listener\r\n   */\n\n  this._onML = null;\n  /**\r\n   * _addEventListeners\r\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\r\n   * Unsend message promises\r\n   * where the sending is still in progress\r\n   * @type {Set<Promise>}\r\n   */\n\n  this._uMP = new Set();\n  /**\r\n   * _beforeClose\r\n   * array of promises that will be awaited\r\n   * before the channel is closed\r\n   */\n\n  this._befC = [];\n  /**\r\n   * _preparePromise\r\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\r\n * used to identify if someone overwrites\r\n * window.BroadcastChannel with this\r\n * See methods/native.js\r\n */\n\n\nexports.BroadcastChannel = BroadcastChannel;\nBroadcastChannel._pubkey = true;\n/**\r\n * clears the tmp-folder if is node\r\n * @return {Promise<boolean>} true if has run, false if not node\r\n */\n\nfunction clearNodeFolder(options) {\n  options = (0, _options.fillOptionsWithDefaults)(options);\n  var method = (0, _methodChooser.chooseMethod)(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return _util.PROMISE_RESOLVED_FALSE;\n  }\n}\n/**\r\n * if set, this method is enforced,\r\n * no mather what the options are\r\n */\n\n\nvar ENFORCED_OPTIONS;\n\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\r\n       * In the past when this error appeared, it was realy hard to debug.\r\n       * So now we log the msg together with the error so it at least\r\n       * gives some clue about where in your application this happens.\r\n       */\n      JSON.stringify(msg));\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\r\n * Post a message over the channel\r\n * @returns {Promise} that resolved when the message sending is done\r\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if ((0, _util.isPromise)(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\r\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\r\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\r\n         * Getting the current time in JavaScript has no good precision.\r\n         * So instead of only listening to events that happend 'after' the listener\r\n         * was added, we also listen to events that happended 100ms before it.\r\n         * This ensures that when another process, like a WebWorker, sends events\r\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\r\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\r\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\r\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","map":{"version":3,"sources":["C:/xampp/htdocs/Apeltd/node_modules/broadcast-channel/dist/lib/broadcast-channel.js"],"names":["Object","defineProperty","exports","value","OPEN_BROADCAST_CHANNELS","BroadcastChannel","clearNodeFolder","enforceOptions","_util","require","_methodChooser","_options","Set","lastId","name","options","id","add","ENFORCED_OPTIONS","fillOptionsWithDefaults","method","chooseMethod","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","_prepareChannel","_pubkey","type","then","PROMISE_RESOLVED_FALSE","prototype","postMessage","msg","closed","Error","JSON","stringify","_post","postInternal","onmessage","fn","time","microSeconds","listenObj","_removeListenerObject","_addListenerObject","addEventListener","removeEventListener","obj","find","close","_this","awaitPrepare","PROMISE_RESOLVED_VOID","Promise","all","Array","from","map","_state","isClosed","broadcastChannel","msgObj","data","sendPromise","channel","maybePromise","create","isPromise","s","_hasMessageListeners","length","push","_startListening","filter","o","_stopListening","listenerFn","forEach","listenerObject","hundredMsInMicro","minMessageTime","onMessage"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;\r\nexports.clearNodeFolder = clearNodeFolder;\r\nexports.enforceOptions = enforceOptions;\r\n\r\nvar _util = require(\"./util.js\");\r\n\r\nvar _methodChooser = require(\"./method-chooser.js\");\r\n\r\nvar _options = require(\"./options.js\");\r\n\r\n/**\r\n * Contains all open channels,\r\n * used in tests to ensure everything is closed.\r\n */\r\nvar OPEN_BROADCAST_CHANNELS = new Set();\r\nexports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;\r\nvar lastId = 0;\r\n\r\nvar BroadcastChannel = function BroadcastChannel(name, options) {\r\n  // identifier of the channel to debug stuff\r\n  this.id = lastId++;\r\n  OPEN_BROADCAST_CHANNELS.add(this);\r\n  this.name = name;\r\n\r\n  if (ENFORCED_OPTIONS) {\r\n    options = ENFORCED_OPTIONS;\r\n  }\r\n\r\n  this.options = (0, _options.fillOptionsWithDefaults)(options);\r\n  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening\r\n\r\n  this._iL = false;\r\n  /**\r\n   * _onMessageListener\r\n   * setting onmessage twice,\r\n   * will overwrite the first listener\r\n   */\r\n\r\n  this._onML = null;\r\n  /**\r\n   * _addEventListeners\r\n   */\r\n\r\n  this._addEL = {\r\n    message: [],\r\n    internal: []\r\n  };\r\n  /**\r\n   * Unsend message promises\r\n   * where the sending is still in progress\r\n   * @type {Set<Promise>}\r\n   */\r\n\r\n  this._uMP = new Set();\r\n  /**\r\n   * _beforeClose\r\n   * array of promises that will be awaited\r\n   * before the channel is closed\r\n   */\r\n\r\n  this._befC = [];\r\n  /**\r\n   * _preparePromise\r\n   */\r\n\r\n  this._prepP = null;\r\n\r\n  _prepareChannel(this);\r\n}; // STATICS\r\n\r\n/**\r\n * used to identify if someone overwrites\r\n * window.BroadcastChannel with this\r\n * See methods/native.js\r\n */\r\n\r\n\r\nexports.BroadcastChannel = BroadcastChannel;\r\nBroadcastChannel._pubkey = true;\r\n/**\r\n * clears the tmp-folder if is node\r\n * @return {Promise<boolean>} true if has run, false if not node\r\n */\r\n\r\nfunction clearNodeFolder(options) {\r\n  options = (0, _options.fillOptionsWithDefaults)(options);\r\n  var method = (0, _methodChooser.chooseMethod)(options);\r\n\r\n  if (method.type === 'node') {\r\n    return method.clearNodeFolder().then(function () {\r\n      return true;\r\n    });\r\n  } else {\r\n    return _util.PROMISE_RESOLVED_FALSE;\r\n  }\r\n}\r\n/**\r\n * if set, this method is enforced,\r\n * no mather what the options are\r\n */\r\n\r\n\r\nvar ENFORCED_OPTIONS;\r\n\r\nfunction enforceOptions(options) {\r\n  ENFORCED_OPTIONS = options;\r\n} // PROTOTYPE\r\n\r\n\r\nBroadcastChannel.prototype = {\r\n  postMessage: function postMessage(msg) {\r\n    if (this.closed) {\r\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\r\n      /**\r\n       * In the past when this error appeared, it was realy hard to debug.\r\n       * So now we log the msg together with the error so it at least\r\n       * gives some clue about where in your application this happens.\r\n       */\r\n      JSON.stringify(msg));\r\n    }\r\n\r\n    return _post(this, 'message', msg);\r\n  },\r\n  postInternal: function postInternal(msg) {\r\n    return _post(this, 'internal', msg);\r\n  },\r\n\r\n  set onmessage(fn) {\r\n    var time = this.method.microSeconds();\r\n    var listenObj = {\r\n      time: time,\r\n      fn: fn\r\n    };\r\n\r\n    _removeListenerObject(this, 'message', this._onML);\r\n\r\n    if (fn && typeof fn === 'function') {\r\n      this._onML = listenObj;\r\n\r\n      _addListenerObject(this, 'message', listenObj);\r\n    } else {\r\n      this._onML = null;\r\n    }\r\n  },\r\n\r\n  addEventListener: function addEventListener(type, fn) {\r\n    var time = this.method.microSeconds();\r\n    var listenObj = {\r\n      time: time,\r\n      fn: fn\r\n    };\r\n\r\n    _addListenerObject(this, type, listenObj);\r\n  },\r\n  removeEventListener: function removeEventListener(type, fn) {\r\n    var obj = this._addEL[type].find(function (obj) {\r\n      return obj.fn === fn;\r\n    });\r\n\r\n    _removeListenerObject(this, type, obj);\r\n  },\r\n  close: function close() {\r\n    var _this = this;\r\n\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\r\n    this.closed = true;\r\n    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;\r\n    this._onML = null;\r\n    this._addEL.message = [];\r\n    return awaitPrepare // wait until all current sending are processed\r\n    .then(function () {\r\n      return Promise.all(Array.from(_this._uMP));\r\n    }) // run before-close hooks\r\n    .then(function () {\r\n      return Promise.all(_this._befC.map(function (fn) {\r\n        return fn();\r\n      }));\r\n    }) // close the channel\r\n    .then(function () {\r\n      return _this.method.close(_this._state);\r\n    });\r\n  },\r\n\r\n  get type() {\r\n    return this.method.type;\r\n  },\r\n\r\n  get isClosed() {\r\n    return this.closed;\r\n  }\r\n\r\n};\r\n/**\r\n * Post a message over the channel\r\n * @returns {Promise} that resolved when the message sending is done\r\n */\r\n\r\nfunction _post(broadcastChannel, type, msg) {\r\n  var time = broadcastChannel.method.microSeconds();\r\n  var msgObj = {\r\n    time: time,\r\n    type: type,\r\n    data: msg\r\n  };\r\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;\r\n  return awaitPrepare.then(function () {\r\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\r\n\r\n    broadcastChannel._uMP.add(sendPromise);\r\n\r\n    sendPromise[\"catch\"]().then(function () {\r\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\r\n    });\r\n    return sendPromise;\r\n  });\r\n}\r\n\r\nfunction _prepareChannel(channel) {\r\n  var maybePromise = channel.method.create(channel.name, channel.options);\r\n\r\n  if ((0, _util.isPromise)(maybePromise)) {\r\n    channel._prepP = maybePromise;\r\n    maybePromise.then(function (s) {\r\n      // used in tests to simulate slow runtime\r\n\r\n      /*if (channel.options.prepareDelay) {\r\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\r\n      }*/\r\n      channel._state = s;\r\n    });\r\n  } else {\r\n    channel._state = maybePromise;\r\n  }\r\n}\r\n\r\nfunction _hasMessageListeners(channel) {\r\n  if (channel._addEL.message.length > 0) return true;\r\n  if (channel._addEL.internal.length > 0) return true;\r\n  return false;\r\n}\r\n\r\nfunction _addListenerObject(channel, type, obj) {\r\n  channel._addEL[type].push(obj);\r\n\r\n  _startListening(channel);\r\n}\r\n\r\nfunction _removeListenerObject(channel, type, obj) {\r\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\r\n    return o !== obj;\r\n  });\r\n\r\n  _stopListening(channel);\r\n}\r\n\r\nfunction _startListening(channel) {\r\n  if (!channel._iL && _hasMessageListeners(channel)) {\r\n    // someone is listening, start subscribing\r\n    var listenerFn = function listenerFn(msgObj) {\r\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\r\n        /**\r\n         * Getting the current time in JavaScript has no good precision.\r\n         * So instead of only listening to events that happend 'after' the listener\r\n         * was added, we also listen to events that happended 100ms before it.\r\n         * This ensures that when another process, like a WebWorker, sends events\r\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\r\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\r\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\r\n         */\r\n        var hundredMsInMicro = 100 * 1000;\r\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\r\n\r\n        if (msgObj.time >= minMessageTime) {\r\n          listenerObject.fn(msgObj.data);\r\n        }\r\n      });\r\n    };\r\n\r\n    var time = channel.method.microSeconds();\r\n\r\n    if (channel._prepP) {\r\n      channel._prepP.then(function () {\r\n        channel._iL = true;\r\n        channel.method.onMessage(channel._state, listenerFn, time);\r\n      });\r\n    } else {\r\n      channel._iL = true;\r\n      channel.method.onMessage(channel._state, listenerFn, time);\r\n    }\r\n  }\r\n}\r\n\r\nfunction _stopListening(channel) {\r\n  if (channel._iL && !_hasMessageListeners(channel)) {\r\n    // noone is listening, stop subscribing\r\n    channel._iL = false;\r\n    var time = channel.method.microSeconds();\r\n    channel.method.onMessage(channel._state, null, time);\r\n  }\r\n}"]},"metadata":{},"sourceType":"script"}