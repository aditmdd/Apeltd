{"ast":null,"code":"/**\r\n * this is a set which automatically forgets\r\n * a given entry when a new entry is set and the ttl\r\n * of the old one is over\r\n */\nvar ObliviousSet =\n/** @class */\nfunction () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.set = new Set();\n    this.timeMap = new Map();\n  }\n\n  ObliviousSet.prototype.has = function (value) {\n    return this.set.has(value);\n  };\n\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n\n    this.timeMap.set(value, now());\n    this.set.add(value);\n    /**\r\n     * When a new value is added,\r\n     * start the cleanup at the next tick\r\n     * to not block the cpu for more important stuff\r\n     * that might happen.\r\n     */\n\n    setTimeout(function () {\n      removeTooOldValues(_this);\n    }, 0);\n  };\n\n  ObliviousSet.prototype.clear = function () {\n    this.set.clear();\n    this.timeMap.clear();\n  };\n\n  return ObliviousSet;\n}();\n\nexport { ObliviousSet };\n/**\r\n * Removes all entries from the set\r\n * where the TTL has expired\r\n */\n\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.set[Symbol.iterator]();\n  /**\r\n   * Because we can assume the new values are added at the bottom,\r\n   * we start from the top and stop as soon as we reach a non-too-old value.\r\n   */\n\n  while (true) {\n    var value = iterator.next().value;\n\n    if (!value) {\n      return; // no more elements\n    }\n\n    var time = obliviousSet.timeMap.get(value);\n\n    if (time < olderThen) {\n      obliviousSet.timeMap.delete(value);\n      obliviousSet.set.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AACA;;;;AAIG;AACH,IAAA,YAAA;AAAA;AAAA,YAAA;AAGI,WAAA,YAAA,CACoB,GADpB,EAC+B;AAAX,SAAA,GAAA,GAAA,GAAA;AAHJ,SAAA,GAAA,GAAM,IAAI,GAAJ,EAAN;AACA,SAAA,OAAA,GAAU,IAAI,GAAJ,EAAV;AAGX;;AAEL,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,KAAJ,EAAY;AACR,WAAO,KAAK,GAAL,CAAS,GAAT,CAAa,KAAb,CAAP;AACH,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,KAAJ,EAAY;AAAZ,QAAA,KAAA,GAAA,IAAA;;AACI,SAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,EAAwB,GAAG,EAA3B;AACA,SAAK,GAAL,CAAS,GAAT,CAAa,KAAb;AAEA;;;;;AAKG;;AACH,IAAA,UAAU,CAAC,YAAA;AACP,MAAA,kBAAkB,CAAC,KAAD,CAAlB;AACH,KAFS,EAEP,CAFO,CAAV;AAGH,GAbD;;AAeA,EAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACI,SAAK,GAAL,CAAS,KAAT;AACA,SAAK,OAAL,CAAa,KAAb;AACH,GAHD;;AAIJ,SAAA,YAAA;AAAC,CA9BD,EAAA;;;AAiCA;;;AAGG;;AACH,OAAM,SAAU,kBAAV,CACF,YADE,EACwB;AAE1B,MAAM,SAAS,GAAG,GAAG,KAAK,YAAY,CAAC,GAAvC;AACA,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAb,CAAiB,MAAM,CAAC,QAAxB,GAAjB;AAEA;;;AAGG;;AACH,SAAO,IAAP,EAAa;AACT,QAAM,KAAK,GAAG,QAAQ,CAAC,IAAT,GAAgB,KAA9B;;AACA,QAAI,CAAC,KAAL,EAAY;AACR,aADQ,CACA;AACX;;AACD,QAAM,IAAI,GAAG,YAAY,CAAC,OAAb,CAAqB,GAArB,CAAyB,KAAzB,CAAb;;AACA,QAAI,IAAI,GAAG,SAAX,EAAsB;AAClB,MAAA,YAAY,CAAC,OAAb,CAAqB,MAArB,CAA4B,KAA5B;AACA,MAAA,YAAY,CAAC,GAAb,CAAiB,MAAjB,CAAwB,KAAxB;AACH,KAHD,MAGO;AACH;AACA;AACH;AACJ;AACJ;AAED,OAAM,SAAU,GAAV,GAAa;AACf,SAAO,IAAI,IAAJ,GAAW,OAAX,EAAP;AACH","sourceRoot":"","sourcesContent":["/**\r\n * this is a set which automatically forgets\r\n * a given entry when a new entry is set and the ttl\r\n * of the old one is over\r\n */\r\nvar ObliviousSet = /** @class */ (function () {\r\n    function ObliviousSet(ttl) {\r\n        this.ttl = ttl;\r\n        this.set = new Set();\r\n        this.timeMap = new Map();\r\n    }\r\n    ObliviousSet.prototype.has = function (value) {\r\n        return this.set.has(value);\r\n    };\r\n    ObliviousSet.prototype.add = function (value) {\r\n        var _this = this;\r\n        this.timeMap.set(value, now());\r\n        this.set.add(value);\r\n        /**\r\n         * When a new value is added,\r\n         * start the cleanup at the next tick\r\n         * to not block the cpu for more important stuff\r\n         * that might happen.\r\n         */\r\n        setTimeout(function () {\r\n            removeTooOldValues(_this);\r\n        }, 0);\r\n    };\r\n    ObliviousSet.prototype.clear = function () {\r\n        this.set.clear();\r\n        this.timeMap.clear();\r\n    };\r\n    return ObliviousSet;\r\n}());\r\nexport { ObliviousSet };\r\n/**\r\n * Removes all entries from the set\r\n * where the TTL has expired\r\n */\r\nexport function removeTooOldValues(obliviousSet) {\r\n    var olderThen = now() - obliviousSet.ttl;\r\n    var iterator = obliviousSet.set[Symbol.iterator]();\r\n    /**\r\n     * Because we can assume the new values are added at the bottom,\r\n     * we start from the top and stop as soon as we reach a non-too-old value.\r\n     */\r\n    while (true) {\r\n        var value = iterator.next().value;\r\n        if (!value) {\r\n            return; // no more elements\r\n        }\r\n        var time = obliviousSet.timeMap.get(value);\r\n        if (time < olderThen) {\r\n            obliviousSet.timeMap.delete(value);\r\n            obliviousSet.set.delete(value);\r\n        }\r\n        else {\r\n            // We reached a value that is not old enough\r\n            return;\r\n        }\r\n    }\r\n}\r\nexport function now() {\r\n    return new Date().getTime();\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}