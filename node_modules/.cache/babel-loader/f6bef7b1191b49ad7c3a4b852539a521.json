{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.beLeader = beLeader;\nexports.createLeaderElection = createLeaderElection;\n\nvar _util = require(\"./util.js\");\n\nvar _unload = require(\"unload\");\n\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this.hasLeader = false;\n  this.isDead = false;\n  this.token = (0, _util.randomToken)();\n  /**\r\n   * Apply Queue,\r\n   * used to ensure we do not run applyOnce()\r\n   * in parallel.\r\n   */\n\n  this._aplQ = _util.PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\n\n  this._aplQC = 0; // things to clean up\n\n  this._unl = []; // _unloads\n\n  this._lstns = []; // _listeners\n\n  this._dpL = function () {}; // onduplicate listener\n\n\n  this._dpLC = false; // true when onduplicate called\n\n  /**\r\n   * Even when the own instance is not applying,\r\n   * we still listen to messages to ensure the hasLeader flag\r\n   * is set correctly.\r\n   */\n\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this.hasLeader = false;\n      }\n\n      if (msg.action === 'tell') {\n        _this.hasLeader = true;\n      }\n    }\n  };\n\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n\n  this._lstns.push(hasLeaderListener);\n};\n\nLeaderElection.prototype = {\n  /**\r\n   * Returns true if the instance is leader,\r\n   * false if not.\r\n   * @async\r\n   */\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n\n    if (this.isLeader) {\n      return (0, _util.sleep)(0, true);\n    }\n\n    if (this.isDead) {\n      return (0, _util.sleep)(0, false);\n    }\n    /**\r\n     * Already applying more then once,\r\n     * -> wait for the apply queue to be finished.\r\n     */\n\n\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n    /**\r\n     * Add a new apply-run\r\n     */\n\n\n    var applyRun = function applyRun() {\n      /**\r\n       * Optimization shortcuts.\r\n       * Directly return if a previous run\r\n       * has already elected a leader.\r\n       */\n      if (_this2.isLeader) {\n        return _util.PROMISE_RESOLVED_TRUE;\n      }\n\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\r\n       * Resolves when a stop criteria is reached.\r\n       * Uses as a performance shortcut so we do not\r\n       * have to await the responseTime when it is already clear\r\n       * that the election failed.\r\n       */\n\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var recieved = [];\n\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          recieved.push(msg);\n\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\r\n               * other has higher token\r\n               * -> stop applying and let other become leader.\r\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2.hasLeader = true;\n          }\n        }\n      };\n\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n      /**\r\n       * If the applyOnce() call came from the fallbackInterval,\r\n       * we can assume that the election runs in the background and\r\n       * not critical process is waiting for it.\r\n       * When this is true, we give the other intances\r\n       * more time to answer to messages in the election cycle.\r\n       * This makes it less likely to elect duplicate leaders.\r\n       * But also it takes longer which is not a problem because we anyway\r\n       * run in the background.\r\n       */\n\n\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      }) // send again in case another instance was just created\n      .then(function () {\n        return _sendMessage(_this2, 'apply');\n      }) // let others time to respond\n      .then(function () {\n        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n\n      return applyPromise;\n    };\n\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if (\n    /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n\n    return this._aLP;\n  },\n\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n\n  die: function die() {\n    var _this3 = this;\n\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n\n    this._lstns = [];\n\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n\n    this._unl = [];\n\n    if (this.isLeader) {\n      this.hasLeader = false;\n      this.isLeader = false;\n    }\n\n    this.isDead = true;\n    return _sendMessage(this, 'death');\n  }\n};\n/**\r\n * @param leaderElector {LeaderElector}\r\n */\n\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return _util.PROMISE_RESOLVED_VOID;\n  }\n\n  return new Promise(function (res) {\n    var resolved = false;\n\n    function finish() {\n      if (resolved) {\n        return;\n      }\n\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    } // try once now\n\n\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n    /**\r\n     * Try on fallbackInterval\r\n     * @recursive\r\n     */\n\n    var tryOnFallBack = function tryOnFallBack() {\n      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n\n    tryOnFallBack(); // try when other leader dies\n\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\n/**\r\n * sends and internal message over the broadcast-channel\r\n */\n\n\nfunction _sendMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\n\nfunction beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector.hasLeader = true;\n  var unloadFn = (0, _unload.add)(function () {\n    return leaderElector.die();\n  });\n\n  leaderElector._unl.push(unloadFn);\n\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell');\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\r\n       * another instance is also leader!\r\n       * This can happen on rare events\r\n       * like when the CPU is at 100% for long time\r\n       * or the tabs are open very long and the browser throttles them.\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\r\n       */\n      leaderElector._dpLC = true;\n\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n\n\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n\n  leaderElector._lstns.push(isLeaderListener);\n\n  return _sendMessage(leaderElector, 'tell');\n}\n\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n\n  return options;\n}\n\nfunction createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = new LeaderElection(channel, options);\n\n  channel._befC.push(function () {\n    return elector.die();\n  });\n\n  channel._leaderElector = elector;\n  return elector;\n}","map":{"version":3,"sources":["C:/xampp/htdocs/Apeltd/node_modules/broadcast-channel/dist/lib/leader-election.js"],"names":["Object","defineProperty","exports","value","beLeader","createLeaderElection","_util","require","_unload","LeaderElection","broadcastChannel","options","_this","_options","isLeader","hasLeader","isDead","token","randomToken","_aplQ","PROMISE_RESOLVED_VOID","_aplQC","_unl","_lstns","_dpL","_dpLC","hasLeaderListener","msg","context","action","addEventListener","push","prototype","applyOnce","isFromFallbackInterval","_this2","sleep","applyRun","PROMISE_RESOLVED_TRUE","stopCriteria","stopCriteriaPromiseResolve","stopCriteriaPromise","Promise","res","recieved","handleMessage","waitForAnswerTime","responseTime","applyPromise","_sendMessage","then","race","reject","Error","removeEventListener","awaitLeadership","_aLP","_awaitLeadershipOnce","onduplicate","fn","die","_this3","forEach","listener","uFn","remove","leaderElector","resolved","finish","whenDeathListener","tryOnFallBack","fallbackInterval","msgJson","postInternal","unloadFn","add","isLeaderListener","fillOptionsWithDefaults","channel","JSON","parse","stringify","method","averageResponseTime","_leaderElector","elector","_befC"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.beLeader = beLeader;\r\nexports.createLeaderElection = createLeaderElection;\r\n\r\nvar _util = require(\"./util.js\");\r\n\r\nvar _unload = require(\"unload\");\r\n\r\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\r\n  var _this = this;\r\n\r\n  this.broadcastChannel = broadcastChannel;\r\n  this._options = options;\r\n  this.isLeader = false;\r\n  this.hasLeader = false;\r\n  this.isDead = false;\r\n  this.token = (0, _util.randomToken)();\r\n  /**\r\n   * Apply Queue,\r\n   * used to ensure we do not run applyOnce()\r\n   * in parallel.\r\n   */\r\n\r\n  this._aplQ = _util.PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\r\n\r\n  this._aplQC = 0; // things to clean up\r\n\r\n  this._unl = []; // _unloads\r\n\r\n  this._lstns = []; // _listeners\r\n\r\n  this._dpL = function () {}; // onduplicate listener\r\n\r\n\r\n  this._dpLC = false; // true when onduplicate called\r\n\r\n  /**\r\n   * Even when the own instance is not applying,\r\n   * we still listen to messages to ensure the hasLeader flag\r\n   * is set correctly.\r\n   */\r\n\r\n  var hasLeaderListener = function hasLeaderListener(msg) {\r\n    if (msg.context === 'leader') {\r\n      if (msg.action === 'death') {\r\n        _this.hasLeader = false;\r\n      }\r\n\r\n      if (msg.action === 'tell') {\r\n        _this.hasLeader = true;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\r\n\r\n  this._lstns.push(hasLeaderListener);\r\n};\r\n\r\nLeaderElection.prototype = {\r\n  /**\r\n   * Returns true if the instance is leader,\r\n   * false if not.\r\n   * @async\r\n   */\r\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\r\n  isFromFallbackInterval) {\r\n    var _this2 = this;\r\n\r\n    if (this.isLeader) {\r\n      return (0, _util.sleep)(0, true);\r\n    }\r\n\r\n    if (this.isDead) {\r\n      return (0, _util.sleep)(0, false);\r\n    }\r\n    /**\r\n     * Already applying more then once,\r\n     * -> wait for the apply queue to be finished.\r\n     */\r\n\r\n\r\n    if (this._aplQC > 1) {\r\n      return this._aplQ;\r\n    }\r\n    /**\r\n     * Add a new apply-run\r\n     */\r\n\r\n\r\n    var applyRun = function applyRun() {\r\n      /**\r\n       * Optimization shortcuts.\r\n       * Directly return if a previous run\r\n       * has already elected a leader.\r\n       */\r\n      if (_this2.isLeader) {\r\n        return _util.PROMISE_RESOLVED_TRUE;\r\n      }\r\n\r\n      var stopCriteria = false;\r\n      var stopCriteriaPromiseResolve;\r\n      /**\r\n       * Resolves when a stop criteria is reached.\r\n       * Uses as a performance shortcut so we do not\r\n       * have to await the responseTime when it is already clear\r\n       * that the election failed.\r\n       */\r\n\r\n      var stopCriteriaPromise = new Promise(function (res) {\r\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\r\n          stopCriteria = true;\r\n          res();\r\n        };\r\n      });\r\n      var recieved = [];\r\n\r\n      var handleMessage = function handleMessage(msg) {\r\n        if (msg.context === 'leader' && msg.token != _this2.token) {\r\n          recieved.push(msg);\r\n\r\n          if (msg.action === 'apply') {\r\n            // other is applying\r\n            if (msg.token > _this2.token) {\r\n              /**\r\n               * other has higher token\r\n               * -> stop applying and let other become leader.\r\n               */\r\n              stopCriteriaPromiseResolve();\r\n            }\r\n          }\r\n\r\n          if (msg.action === 'tell') {\r\n            // other is already leader\r\n            stopCriteriaPromiseResolve();\r\n            _this2.hasLeader = true;\r\n          }\r\n        }\r\n      };\r\n\r\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\r\n      /**\r\n       * If the applyOnce() call came from the fallbackInterval,\r\n       * we can assume that the election runs in the background and\r\n       * not critical process is waiting for it.\r\n       * When this is true, we give the other intances\r\n       * more time to answer to messages in the election cycle.\r\n       * This makes it less likely to elect duplicate leaders.\r\n       * But also it takes longer which is not a problem because we anyway\r\n       * run in the background.\r\n       */\r\n\r\n\r\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\r\n\r\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\r\n      .then(function () {\r\n        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\r\n          return Promise.reject(new Error());\r\n        })]);\r\n      }) // send again in case another instance was just created\r\n      .then(function () {\r\n        return _sendMessage(_this2, 'apply');\r\n      }) // let others time to respond\r\n      .then(function () {\r\n        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\r\n          return Promise.reject(new Error());\r\n        })]);\r\n      })[\"catch\"](function () {}).then(function () {\r\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\r\n\r\n        if (!stopCriteria) {\r\n          // no stop criteria -> own is leader\r\n          return beLeader(_this2).then(function () {\r\n            return true;\r\n          });\r\n        } else {\r\n          // other is leader\r\n          return false;\r\n        }\r\n      });\r\n\r\n      return applyPromise;\r\n    };\r\n\r\n    this._aplQC = this._aplQC + 1;\r\n    this._aplQ = this._aplQ.then(function () {\r\n      return applyRun();\r\n    }).then(function () {\r\n      _this2._aplQC = _this2._aplQC - 1;\r\n    });\r\n    return this._aplQ.then(function () {\r\n      return _this2.isLeader;\r\n    });\r\n  },\r\n  awaitLeadership: function awaitLeadership() {\r\n    if (\r\n    /* _awaitLeadershipPromise */\r\n    !this._aLP) {\r\n      this._aLP = _awaitLeadershipOnce(this);\r\n    }\r\n\r\n    return this._aLP;\r\n  },\r\n\r\n  set onduplicate(fn) {\r\n    this._dpL = fn;\r\n  },\r\n\r\n  die: function die() {\r\n    var _this3 = this;\r\n\r\n    this._lstns.forEach(function (listener) {\r\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\r\n    });\r\n\r\n    this._lstns = [];\r\n\r\n    this._unl.forEach(function (uFn) {\r\n      return uFn.remove();\r\n    });\r\n\r\n    this._unl = [];\r\n\r\n    if (this.isLeader) {\r\n      this.hasLeader = false;\r\n      this.isLeader = false;\r\n    }\r\n\r\n    this.isDead = true;\r\n    return _sendMessage(this, 'death');\r\n  }\r\n};\r\n/**\r\n * @param leaderElector {LeaderElector}\r\n */\r\n\r\nfunction _awaitLeadershipOnce(leaderElector) {\r\n  if (leaderElector.isLeader) {\r\n    return _util.PROMISE_RESOLVED_VOID;\r\n  }\r\n\r\n  return new Promise(function (res) {\r\n    var resolved = false;\r\n\r\n    function finish() {\r\n      if (resolved) {\r\n        return;\r\n      }\r\n\r\n      resolved = true;\r\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\r\n      res(true);\r\n    } // try once now\r\n\r\n\r\n    leaderElector.applyOnce().then(function () {\r\n      if (leaderElector.isLeader) {\r\n        finish();\r\n      }\r\n    });\r\n    /**\r\n     * Try on fallbackInterval\r\n     * @recursive\r\n     */\r\n\r\n    var tryOnFallBack = function tryOnFallBack() {\r\n      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function () {\r\n        if (leaderElector.isDead || resolved) {\r\n          return;\r\n        }\r\n\r\n        if (leaderElector.isLeader) {\r\n          finish();\r\n        } else {\r\n          return leaderElector.applyOnce(true).then(function () {\r\n            if (leaderElector.isLeader) {\r\n              finish();\r\n            } else {\r\n              tryOnFallBack();\r\n            }\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    tryOnFallBack(); // try when other leader dies\r\n\r\n    var whenDeathListener = function whenDeathListener(msg) {\r\n      if (msg.context === 'leader' && msg.action === 'death') {\r\n        leaderElector.hasLeader = false;\r\n        leaderElector.applyOnce().then(function () {\r\n          if (leaderElector.isLeader) {\r\n            finish();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\r\n\r\n    leaderElector._lstns.push(whenDeathListener);\r\n  });\r\n}\r\n/**\r\n * sends and internal message over the broadcast-channel\r\n */\r\n\r\n\r\nfunction _sendMessage(leaderElector, action) {\r\n  var msgJson = {\r\n    context: 'leader',\r\n    action: action,\r\n    token: leaderElector.token\r\n  };\r\n  return leaderElector.broadcastChannel.postInternal(msgJson);\r\n}\r\n\r\nfunction beLeader(leaderElector) {\r\n  leaderElector.isLeader = true;\r\n  leaderElector.hasLeader = true;\r\n  var unloadFn = (0, _unload.add)(function () {\r\n    return leaderElector.die();\r\n  });\r\n\r\n  leaderElector._unl.push(unloadFn);\r\n\r\n  var isLeaderListener = function isLeaderListener(msg) {\r\n    if (msg.context === 'leader' && msg.action === 'apply') {\r\n      _sendMessage(leaderElector, 'tell');\r\n    }\r\n\r\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\r\n      /**\r\n       * another instance is also leader!\r\n       * This can happen on rare events\r\n       * like when the CPU is at 100% for long time\r\n       * or the tabs are open very long and the browser throttles them.\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\r\n       */\r\n      leaderElector._dpLC = true;\r\n\r\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\r\n\r\n\r\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\r\n\r\n    }\r\n  };\r\n\r\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\r\n\r\n  leaderElector._lstns.push(isLeaderListener);\r\n\r\n  return _sendMessage(leaderElector, 'tell');\r\n}\r\n\r\nfunction fillOptionsWithDefaults(options, channel) {\r\n  if (!options) options = {};\r\n  options = JSON.parse(JSON.stringify(options));\r\n\r\n  if (!options.fallbackInterval) {\r\n    options.fallbackInterval = 3000;\r\n  }\r\n\r\n  if (!options.responseTime) {\r\n    options.responseTime = channel.method.averageResponseTime(channel.options);\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\nfunction createLeaderElection(channel, options) {\r\n  if (channel._leaderElector) {\r\n    throw new Error('BroadcastChannel already has a leader-elector');\r\n  }\r\n\r\n  options = fillOptionsWithDefaults(options, channel);\r\n  var elector = new LeaderElection(channel, options);\r\n\r\n  channel._befC.push(function () {\r\n    return elector.die();\r\n  });\r\n\r\n  channel._leaderElector = elector;\r\n  return elector;\r\n}"]},"metadata":{},"sourceType":"script"}