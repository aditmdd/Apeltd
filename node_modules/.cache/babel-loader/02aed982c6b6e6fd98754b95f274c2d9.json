{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport detectEthereumProvider from '@metamask/detect-provider';\nimport { BaseAdapter, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, WALLET_ADAPTERS, ADAPTER_STATUS, WalletInitializationError, ADAPTER_EVENTS, getChainConfig, WalletLoginError } from '@web3auth/base';\n\nclass MetamaskAdapter extends BaseAdapter {\n  constructor() {\n    let adapterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.METAMASK);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    _defineProperty(this, \"metamaskProvider\", null);\n\n    this.chainConfig = adapterOptions.chainConfig || null;\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {\n      return this.metamaskProvider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements();\n    this.metamaskProvider = await detectEthereumProvider({\n      mustBeMetaMask: true\n    });\n    if (!this.metamaskProvider) throw WalletInitializationError.notInstalled(\"Metamask extension is not installed\");\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);\n\n    try {\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  setAdapterSettings(_) {}\n\n  async connect() {\n    super.checkConnectionRequirements(); // set default to mainnet\n\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\n      adapter: WALLET_ADAPTERS.METAMASK\n    });\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not able to connect with metamask\");\n\n    try {\n      await this.metamaskProvider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const {\n        chainId\n      } = this.metamaskProvider;\n\n      if (chainId !== this.chainConfig.chainId) {\n        await this.switchChain(this.chainConfig);\n      }\n\n      this.status = ADAPTER_STATUS.CONNECTED;\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Failed to connect with provider\");\n      this.provider.once(\"disconnect\", () => {\n        // ready to be connected again\n        this.disconnect();\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.METAMASK,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw WalletLoginError.connectionError(\"Failed to login with metamask wallet\");\n    }\n  }\n\n  async disconnect() {\n    var _this$provider;\n\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.metamaskProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async switchChain(chainConfig) {\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n\n    try {\n      await this.metamaskProvider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId\n        }]\n      });\n    } catch (switchError) {\n      // This error code indicates that the chain has not been added to MetaMask.\n      if (switchError.code === 4902) {\n        await this.metamaskProvider.request({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId: chainConfig.chainId,\n            chainName: chainConfig.displayName,\n            rpcUrls: [chainConfig.rpcTarget]\n          }]\n        });\n      } else {\n        throw switchError;\n      }\n    }\n  }\n\n}\n\nexport { MetamaskAdapter };","map":{"version":3,"sources":["../src/metamaskAdapter.ts"],"names":["ADAPTER_NAMESPACES","EIP155","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","WALLET_ADAPTERS","METAMASK","ADAPTER_STATUS","NOT_READY","constructor","adapterOptions","provider","init","detectEthereumProvider","mustBeMetaMask","WalletInitializationError","ADAPTER_EVENTS","options","setAdapterSettings","connect","getChainConfig","adapter","WalletLoginError","method","chainId","reconnected","rehydrated","disconnect","cleanup","getUserInfo","switchChain","params","chainConfig","switchError","chainName","rpcUrls"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\r\nimport detectEthereumProvider from '@metamask/detect-provider';\r\nimport { BaseAdapter, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, WALLET_ADAPTERS, ADAPTER_STATUS, WalletInitializationError, ADAPTER_EVENTS, getChainConfig, WalletLoginError } from '@web3auth/base';\r\n\r\nclass MetamaskAdapter extends BaseAdapter {\r\n  constructor() {\r\n    let adapterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    super();\r\n\r\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\r\n\r\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\r\n\r\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\r\n\r\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.METAMASK);\r\n\r\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\r\n\r\n    _defineProperty(this, \"rehydrated\", false);\r\n\r\n    _defineProperty(this, \"metamaskProvider\", null);\r\n\r\n    this.chainConfig = adapterOptions.chainConfig || null;\r\n  }\r\n\r\n  get provider() {\r\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {\r\n      return this.metamaskProvider;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  set provider(_) {\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  async init(options) {\r\n    super.checkInitializationRequirements();\r\n    this.metamaskProvider = await detectEthereumProvider({\r\n      mustBeMetaMask: true\r\n    });\r\n    if (!this.metamaskProvider) throw WalletInitializationError.notInstalled(\"Metamask extension is not installed\");\r\n    this.status = ADAPTER_STATUS.READY;\r\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);\r\n\r\n    try {\r\n      if (options.autoConnect) {\r\n        this.rehydrated = true;\r\n        await this.connect();\r\n      }\r\n    } catch (error) {\r\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\r\n    }\r\n  }\r\n\r\n  setAdapterSettings(_) {}\r\n\r\n  async connect() {\r\n    super.checkConnectionRequirements(); // set default to mainnet\r\n\r\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\r\n    this.status = ADAPTER_STATUS.CONNECTING;\r\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\r\n      adapter: WALLET_ADAPTERS.METAMASK\r\n    });\r\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not able to connect with metamask\");\r\n\r\n    try {\r\n      await this.metamaskProvider.request({\r\n        method: \"eth_requestAccounts\"\r\n      });\r\n      const {\r\n        chainId\r\n      } = this.metamaskProvider;\r\n\r\n      if (chainId !== this.chainConfig.chainId) {\r\n        await this.switchChain(this.chainConfig);\r\n      }\r\n\r\n      this.status = ADAPTER_STATUS.CONNECTED;\r\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Failed to connect with provider\");\r\n      this.provider.once(\"disconnect\", () => {\r\n        // ready to be connected again\r\n        this.disconnect();\r\n      });\r\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\r\n        adapter: WALLET_ADAPTERS.METAMASK,\r\n        reconnected: this.rehydrated\r\n      });\r\n      return this.provider;\r\n    } catch (error) {\r\n      // ready again to be connected\r\n      this.status = ADAPTER_STATUS.READY;\r\n      this.rehydrated = false;\r\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\r\n      throw WalletLoginError.connectionError(\"Failed to login with metamask wallet\");\r\n    }\r\n  }\r\n\r\n  async disconnect() {\r\n    var _this$provider;\r\n\r\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\r\n      cleanup: false\r\n    };\r\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\r\n    (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();\r\n\r\n    if (options.cleanup) {\r\n      this.status = ADAPTER_STATUS.NOT_READY;\r\n      this.metamaskProvider = null;\r\n    } else {\r\n      // ready to be connected again\r\n      this.status = ADAPTER_STATUS.READY;\r\n    }\r\n\r\n    this.rehydrated = false;\r\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\r\n  }\r\n\r\n  async getUserInfo() {\r\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\r\n    return {};\r\n  }\r\n\r\n  async switchChain(chainConfig) {\r\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\r\n\r\n    try {\r\n      await this.metamaskProvider.request({\r\n        method: \"wallet_switchEthereumChain\",\r\n        params: [{\r\n          chainId: chainConfig.chainId\r\n        }]\r\n      });\r\n    } catch (switchError) {\r\n      // This error code indicates that the chain has not been added to MetaMask.\r\n      if (switchError.code === 4902) {\r\n        await this.metamaskProvider.request({\r\n          method: \"wallet_addEthereumChain\",\r\n          params: [{\r\n            chainId: chainConfig.chainId,\r\n            chainName: chainConfig.displayName,\r\n            rpcUrls: [chainConfig.rpcTarget]\r\n          }]\r\n        });\r\n      } else {\r\n        throw switchError;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { MetamaskAdapter };\r\n//# sourceMappingURL=metamaskAdapter.esm.js.map\r\n"]},"metadata":{},"sourceType":"module"}