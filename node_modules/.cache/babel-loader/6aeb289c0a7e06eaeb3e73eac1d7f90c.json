{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.averageResponseTime = averageResponseTime;\nexports.canBeUsed = canBeUsed;\nexports.cleanOldMessages = cleanOldMessages;\nexports.close = close;\nexports.create = create;\nexports.createDatabase = createDatabase;\nexports[\"default\"] = void 0;\nexports.getAllMessages = getAllMessages;\nexports.getIdb = getIdb;\nexports.getMessagesHigherThan = getMessagesHigherThan;\nexports.getOldMessages = getOldMessages;\nexports.microSeconds = void 0;\nexports.onMessage = onMessage;\nexports.postMessage = postMessage;\nexports.removeMessageById = removeMessageById;\nexports.type = void 0;\nexports.writeMessage = writeMessage;\n\nvar _util = require(\"../util.js\");\n\nvar _obliviousSet = require(\"oblivious-set\");\n\nvar _options = require(\"../options\");\n/**\r\n * this method uses indexeddb to store the messages\r\n * There is currently no observerAPI for idb\r\n * @link https://github.com/w3c/IndexedDB/issues/51\r\n */\n\n\nvar microSeconds = _util.microSeconds;\nexports.microSeconds = microSeconds;\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nvar type = 'idb';\nexports.type = type;\n\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\n\nfunction createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\r\n * writes the new message to the database\r\n * so other readers can find it\r\n */\n\n\nfunction writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\n\nfunction getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\n\nfunction getMessagesHigherThan(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res) {\n    openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\n\nfunction removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\n\nfunction getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\n\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\n\nfunction create(channelName, options) {\n  options = (0, _options.fillOptionsWithDefaults)(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: (0, _util.randomToken)(),\n\n      /**\r\n       * emittedMessagesIds\r\n       * contains all messages that have been emitted before\r\n       * @type {ObliviousSet}\r\n       */\n      eMIs: new _obliviousSet.ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: _util.PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\r\n     * Handle abrupt closes that do not originate from db.close().\r\n     * This could happen, for example, if the underlying storage is\r\n     * removed or if the user clears the database in the browser's\r\n     * history preferences.\r\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\r\n     * if service-workers are used,\r\n     * we have no 'storage'-event if they post a message,\r\n     * therefore we also have to set an interval\r\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return (0, _util.sleep)(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\r\n * reads all new messages from the database and emits them\r\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return _util.PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return _util.PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\r\n     * there is a bug in iOS where the msgObj can be undefined some times\r\n     * so we filter them out\r\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\r\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return _util.PROMISE_RESOLVED_VOID;\n  });\n}\n\nfunction close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\n\nfunction postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if ((0, _util.randomInt)(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\n\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\n\nfunction canBeUsed() {\n  if (_util.isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\n\nfunction averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\n\nvar _default = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:/xampp/htdocs/Apeltd/node_modules/broadcast-channel/dist/lib/methods/indexed-db.js"],"names":["Object","defineProperty","exports","value","averageResponseTime","canBeUsed","cleanOldMessages","close","create","createDatabase","getAllMessages","getIdb","getMessagesHigherThan","getOldMessages","microSeconds","onMessage","postMessage","removeMessageById","type","writeMessage","_util","require","_obliviousSet","_options","DB_PREFIX","OBJECT_STORE_ID","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","channelName","IndexedDB","dbName","openRequest","open","onupgradeneeded","ev","db","target","result","createObjectStore","keyPath","autoIncrement","dbPromise","Promise","res","rej","onerror","onsuccess","readerUuid","messageJson","time","Date","getTime","writeObject","uuid","data","transaction","oncomplete","objectStore","add","ret","openCursor","cursor","push","lastCursorId","keyRangeValue","IDBKeyRange","bound","Infinity","e","id","request","ttl","olderThen","msgObk","then","tooOld","all","map","msgObj","options","fillOptionsWithDefaults","state","closed","randomToken","eMIs","ObliviousSet","idb","writeBlockPromise","PROMISE_RESOLVED_VOID","messagesCallback","readQueuePromises","onclose","_readLoop","readNewMessages","sleep","fallbackInterval","_filterMessage","has","messagesCallbackTime","newerMessages","useMessages","filter","sort","msgObjA","msgObjB","forEach","channelState","randomInt","fn","isNode","_default"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.averageResponseTime = averageResponseTime;\r\nexports.canBeUsed = canBeUsed;\r\nexports.cleanOldMessages = cleanOldMessages;\r\nexports.close = close;\r\nexports.create = create;\r\nexports.createDatabase = createDatabase;\r\nexports[\"default\"] = void 0;\r\nexports.getAllMessages = getAllMessages;\r\nexports.getIdb = getIdb;\r\nexports.getMessagesHigherThan = getMessagesHigherThan;\r\nexports.getOldMessages = getOldMessages;\r\nexports.microSeconds = void 0;\r\nexports.onMessage = onMessage;\r\nexports.postMessage = postMessage;\r\nexports.removeMessageById = removeMessageById;\r\nexports.type = void 0;\r\nexports.writeMessage = writeMessage;\r\n\r\nvar _util = require(\"../util.js\");\r\n\r\nvar _obliviousSet = require(\"oblivious-set\");\r\n\r\nvar _options = require(\"../options\");\r\n\r\n/**\r\n * this method uses indexeddb to store the messages\r\n * There is currently no observerAPI for idb\r\n * @link https://github.com/w3c/IndexedDB/issues/51\r\n */\r\nvar microSeconds = _util.microSeconds;\r\nexports.microSeconds = microSeconds;\r\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\r\nvar OBJECT_STORE_ID = 'messages';\r\nvar type = 'idb';\r\nexports.type = type;\r\n\r\nfunction getIdb() {\r\n  if (typeof indexedDB !== 'undefined') return indexedDB;\r\n\r\n  if (typeof window !== 'undefined') {\r\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\r\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\r\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction createDatabase(channelName) {\r\n  var IndexedDB = getIdb(); // create table\r\n\r\n  var dbName = DB_PREFIX + channelName;\r\n  var openRequest = IndexedDB.open(dbName, 1);\r\n\r\n  openRequest.onupgradeneeded = function (ev) {\r\n    var db = ev.target.result;\r\n    db.createObjectStore(OBJECT_STORE_ID, {\r\n      keyPath: 'id',\r\n      autoIncrement: true\r\n    });\r\n  };\r\n\r\n  var dbPromise = new Promise(function (res, rej) {\r\n    openRequest.onerror = function (ev) {\r\n      return rej(ev);\r\n    };\r\n\r\n    openRequest.onsuccess = function () {\r\n      res(openRequest.result);\r\n    };\r\n  });\r\n  return dbPromise;\r\n}\r\n/**\r\n * writes the new message to the database\r\n * so other readers can find it\r\n */\r\n\r\n\r\nfunction writeMessage(db, readerUuid, messageJson) {\r\n  var time = new Date().getTime();\r\n  var writeObject = {\r\n    uuid: readerUuid,\r\n    time: time,\r\n    data: messageJson\r\n  };\r\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\r\n  return new Promise(function (res, rej) {\r\n    transaction.oncomplete = function () {\r\n      return res();\r\n    };\r\n\r\n    transaction.onerror = function (ev) {\r\n      return rej(ev);\r\n    };\r\n\r\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\r\n    objectStore.add(writeObject);\r\n  });\r\n}\r\n\r\nfunction getAllMessages(db) {\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n  return new Promise(function (res) {\r\n    objectStore.openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\r\n\r\n        cursor[\"continue\"]();\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction getMessagesHigherThan(db, lastCursorId) {\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n\r\n  function openCursor() {\r\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\r\n    // catches that error, having it open the cursor to the first\r\n    // item. When it gets data it will advance to the desired key.\r\n    try {\r\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\r\n      return objectStore.openCursor(keyRangeValue);\r\n    } catch (e) {\r\n      return objectStore.openCursor();\r\n    }\r\n  }\r\n\r\n  return new Promise(function (res) {\r\n    openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        if (cursor.value.id < lastCursorId + 1) {\r\n          cursor[\"continue\"](lastCursorId + 1);\r\n        } else {\r\n          ret.push(cursor.value);\r\n          cursor[\"continue\"]();\r\n        }\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction removeMessageById(db, id) {\r\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\r\n  return new Promise(function (res) {\r\n    request.onsuccess = function () {\r\n      return res();\r\n    };\r\n  });\r\n}\r\n\r\nfunction getOldMessages(db, ttl) {\r\n  var olderThen = new Date().getTime() - ttl;\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n  return new Promise(function (res) {\r\n    objectStore.openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        var msgObk = cursor.value;\r\n\r\n        if (msgObk.time < olderThen) {\r\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\r\n\r\n          cursor[\"continue\"]();\r\n        } else {\r\n          // no more old messages,\r\n          res(ret);\r\n          return;\r\n        }\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction cleanOldMessages(db, ttl) {\r\n  return getOldMessages(db, ttl).then(function (tooOld) {\r\n    return Promise.all(tooOld.map(function (msgObj) {\r\n      return removeMessageById(db, msgObj.id);\r\n    }));\r\n  });\r\n}\r\n\r\nfunction create(channelName, options) {\r\n  options = (0, _options.fillOptionsWithDefaults)(options);\r\n  return createDatabase(channelName).then(function (db) {\r\n    var state = {\r\n      closed: false,\r\n      lastCursorId: 0,\r\n      channelName: channelName,\r\n      options: options,\r\n      uuid: (0, _util.randomToken)(),\r\n\r\n      /**\r\n       * emittedMessagesIds\r\n       * contains all messages that have been emitted before\r\n       * @type {ObliviousSet}\r\n       */\r\n      eMIs: new _obliviousSet.ObliviousSet(options.idb.ttl * 2),\r\n      // ensures we do not read messages in parrallel\r\n      writeBlockPromise: _util.PROMISE_RESOLVED_VOID,\r\n      messagesCallback: null,\r\n      readQueuePromises: [],\r\n      db: db\r\n    };\r\n    /**\r\n     * Handle abrupt closes that do not originate from db.close().\r\n     * This could happen, for example, if the underlying storage is\r\n     * removed or if the user clears the database in the browser's\r\n     * history preferences.\r\n     */\r\n\r\n    db.onclose = function () {\r\n      state.closed = true;\r\n      if (options.idb.onclose) options.idb.onclose();\r\n    };\r\n    /**\r\n     * if service-workers are used,\r\n     * we have no 'storage'-event if they post a message,\r\n     * therefore we also have to set an interval\r\n     */\r\n\r\n\r\n    _readLoop(state);\r\n\r\n    return state;\r\n  });\r\n}\r\n\r\nfunction _readLoop(state) {\r\n  if (state.closed) return;\r\n  readNewMessages(state).then(function () {\r\n    return (0, _util.sleep)(state.options.idb.fallbackInterval);\r\n  }).then(function () {\r\n    return _readLoop(state);\r\n  });\r\n}\r\n\r\nfunction _filterMessage(msgObj, state) {\r\n  if (msgObj.uuid === state.uuid) return false; // send by own\r\n\r\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\r\n\r\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\r\n\r\n  return true;\r\n}\r\n/**\r\n * reads all new messages from the database and emits them\r\n */\r\n\r\n\r\nfunction readNewMessages(state) {\r\n  // channel already closed\r\n  if (state.closed) return _util.PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages\r\n\r\n  if (!state.messagesCallback) return _util.PROMISE_RESOLVED_VOID;\r\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\r\n    var useMessages = newerMessages\r\n    /**\r\n     * there is a bug in iOS where the msgObj can be undefined some times\r\n     * so we filter them out\r\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\r\n     */\r\n    .filter(function (msgObj) {\r\n      return !!msgObj;\r\n    }).map(function (msgObj) {\r\n      if (msgObj.id > state.lastCursorId) {\r\n        state.lastCursorId = msgObj.id;\r\n      }\r\n\r\n      return msgObj;\r\n    }).filter(function (msgObj) {\r\n      return _filterMessage(msgObj, state);\r\n    }).sort(function (msgObjA, msgObjB) {\r\n      return msgObjA.time - msgObjB.time;\r\n    }); // sort by time\r\n\r\n    useMessages.forEach(function (msgObj) {\r\n      if (state.messagesCallback) {\r\n        state.eMIs.add(msgObj.id);\r\n        state.messagesCallback(msgObj.data);\r\n      }\r\n    });\r\n    return _util.PROMISE_RESOLVED_VOID;\r\n  });\r\n}\r\n\r\nfunction close(channelState) {\r\n  channelState.closed = true;\r\n  channelState.db.close();\r\n}\r\n\r\nfunction postMessage(channelState, messageJson) {\r\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\r\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\r\n  }).then(function () {\r\n    if ((0, _util.randomInt)(0, 10) === 0) {\r\n      /* await (do not await) */\r\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\r\n    }\r\n  });\r\n  return channelState.writeBlockPromise;\r\n}\r\n\r\nfunction onMessage(channelState, fn, time) {\r\n  channelState.messagesCallbackTime = time;\r\n  channelState.messagesCallback = fn;\r\n  readNewMessages(channelState);\r\n}\r\n\r\nfunction canBeUsed() {\r\n  if (_util.isNode) return false;\r\n  var idb = getIdb();\r\n  if (!idb) return false;\r\n  return true;\r\n}\r\n\r\nfunction averageResponseTime(options) {\r\n  return options.idb.fallbackInterval * 2;\r\n}\r\n\r\nvar _default = {\r\n  create: create,\r\n  close: close,\r\n  onMessage: onMessage,\r\n  postMessage: postMessage,\r\n  canBeUsed: canBeUsed,\r\n  type: type,\r\n  averageResponseTime: averageResponseTime,\r\n  microSeconds: microSeconds\r\n};\r\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}